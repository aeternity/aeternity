%% NOTE: This module is mostly generated by
%% aefa_gen_dispatch:gen_dispatch/1
%% See that module for more information.
%% Keep edits in this file to a minimum.
-module(aefa_fate_eval).
-export([eval/2]).

eval('RETURN', EngineState) ->
    aefa_fate_op:return(EngineState);

eval({'RETURNR' , Arg0}, EngineState) ->
    aefa_fate_op:returnr(Arg0, EngineState);

eval({'CALL' , {immediate, Arg0}}, EngineState) ->
    aefa_fate_op:call(Arg0, EngineState);

eval({'CALL_R' , Arg0, {immediate, Arg1}}, EngineState) ->
    aefa_fate_op:call_r(Arg0, Arg1, EngineState);

eval({'CALL_T' , {immediate, Arg0}}, EngineState) ->
    aefa_fate_op:call_t(Arg0, EngineState);

eval({'CALL_TR' , Arg0, {immediate, Arg1}}, EngineState) ->
    aefa_fate_op:call_tr(Arg0, Arg1, EngineState);

eval({'JUMP' , {immediate, Arg0}}, EngineState) ->
    aefa_fate_op:jump(Arg0, EngineState);

eval({'JUMPIF' , Arg0, {immediate, Arg1}}, EngineState) ->
    aefa_fate_op:jumpif(Arg0, Arg1, EngineState);

eval({'SWITCH_V2' , Arg0, {immediate, Arg1}, {immediate, Arg2}}, EngineState) ->
    aefa_fate_op:switch(Arg0, Arg1, Arg2, EngineState);

eval({'SWITCH_V3' , Arg0, {immediate, Arg1}, {immediate, Arg2}, {immediate, Arg3}}, EngineState) ->
    aefa_fate_op:switch(Arg0, Arg1, Arg2, Arg3, EngineState);

eval({'SWITCH_VN' , Arg0, {immediate, Arg1}}, EngineState) ->
    aefa_fate_op:switch(Arg0, Arg1, EngineState);

eval({'PUSH' , Arg0}, EngineState) ->
    {next, aefa_fate_op:push(Arg0, EngineState)};

eval('DUPA', EngineState) ->
    {next, aefa_fate_op:dup(EngineState)};

eval({'DUP' , Arg0}, EngineState) ->
    {next, aefa_fate_op:dup(Arg0, EngineState)};

eval({'POP' , Arg0}, EngineState) ->
    {next, aefa_fate_op:pop(Arg0, EngineState)};

eval({'STORE' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:store(Arg0, Arg1, EngineState)};

eval('INCA', EngineState) ->
    {next, aefa_fate_op:inc(EngineState)};

eval({'INC' , Arg0}, EngineState) ->
    {next, aefa_fate_op:inc(Arg0, EngineState)};

eval('DECA', EngineState) ->
    {next, aefa_fate_op:dec(EngineState)};

eval({'DEC' , Arg0}, EngineState) ->
    {next, aefa_fate_op:dec(Arg0, EngineState)};

eval({'ADD' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:add(Arg0, Arg1, Arg2, EngineState)};

eval({'SUB' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:sub(Arg0, Arg1, Arg2, EngineState)};

eval({'MUL' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:mul(Arg0, Arg1, Arg2, EngineState)};

eval({'DIV' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:divide(Arg0, Arg1, Arg2, EngineState)};

eval({'MOD' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:modulo(Arg0, Arg1, Arg2, EngineState)};

eval({'POW' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:pow(Arg0, Arg1, Arg2, EngineState)};

eval({'LT' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:lt(Arg0, Arg1, Arg2, EngineState)};

eval({'GT' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:gt(Arg0, Arg1, Arg2, EngineState)};

eval({'EQ' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:eq(Arg0, Arg1, Arg2, EngineState)};

eval({'ELT' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:elt(Arg0, Arg1, Arg2, EngineState)};

eval({'EGT' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:egt(Arg0, Arg1, Arg2, EngineState)};

eval({'NEQ' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:neq(Arg0, Arg1, Arg2, EngineState)};

eval({'AND' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:and_op(Arg0, Arg1, Arg2, EngineState)};

eval({'OR' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:or_op(Arg0, Arg1, Arg2, EngineState)};

eval({'NOT' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:not_op(Arg0, Arg1, EngineState)};

eval({'TUPLE' , {immediate, Arg0}}, EngineState) ->
    {next, aefa_fate_op:tuple(Arg0, EngineState)};

eval({'ELEMENT' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:element_op(Arg0, Arg1, Arg2, EngineState)};

eval({'MAP_EMPTY' , Arg0}, EngineState) ->
    {next, aefa_fate_op:map_empty(Arg0, EngineState)};

eval({'MAP_LOOKUP' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:map_lookup(Arg0, Arg1, Arg2, EngineState)};

eval({'MAP_LOOKUPD' , Arg0, Arg1, Arg2, Arg3}, EngineState) ->
    {next, aefa_fate_op:map_lookup(Arg0, Arg1, Arg2, Arg3, EngineState)};

eval({'MAP_UPDATE' , Arg0, Arg1, Arg2, Arg3}, EngineState) ->
    {next, aefa_fate_op:map_update(Arg0, Arg1, Arg2, Arg3, EngineState)};

eval({'MAP_DELETE' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:map_delete(Arg0, Arg1, Arg2, EngineState)};

eval({'MAP_MEMBER' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:map_member(Arg0, Arg1, Arg2, EngineState)};

eval({'MAP_FROM_LIST' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:map_from_list(Arg0, Arg1, EngineState)};

eval({'NIL' , Arg0}, EngineState) ->
    {next, aefa_fate_op:nil(Arg0, EngineState)};

eval({'IS_NIL' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:is_nil(Arg0, Arg1, EngineState)};

eval({'CONS' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:cons(Arg0, Arg1, Arg2, EngineState)};

eval({'HD' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:hd(Arg0, Arg1, EngineState)};

eval({'TL' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:tl(Arg0, Arg1, EngineState)};

eval({'LENGTH' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:length(Arg0, Arg1, EngineState)};

eval({'STR_EQ' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:str_eq(Arg0, Arg1, Arg2, EngineState)};

eval({'STR_JOIN' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:str_join(Arg0, Arg1, Arg2, EngineState)};

eval({'INT_TO_STR' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:int_to_str(Arg0, Arg1, EngineState)};

eval({'ADDR_TO_STR' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:addr_to_str(Arg0, Arg1, EngineState)};

eval({'STR_REVERSE' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:str_reverse(Arg0, Arg1, EngineState)};

eval({'INT_TO_ADDR' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:int_to_addr(Arg0, Arg1, EngineState)};

eval({'VARIANT' , Arg0, Arg1, Arg2, Arg3}, EngineState) ->
    {next, aefa_fate_op:variant(Arg0, Arg1, Arg2, Arg3, EngineState)};

eval({'VARIANT_TEST' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:variant_test(Arg0, Arg1, Arg2, EngineState)};

eval({'VARIANT_ELEMENT' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:variant_element(Arg0, Arg1, Arg2, EngineState)};

eval('BITS_NONEA', EngineState) ->
    {next, aefa_fate_op:bits_none(EngineState)};

eval({'BITS_NONE' , Arg0}, EngineState) ->
    {next, aefa_fate_op:bits_none(Arg0, EngineState)};

eval('BITS_ALLA', EngineState) ->
    {next, aefa_fate_op:bits_all(EngineState)};

eval({'BITS_ALL' , Arg0}, EngineState) ->
    {next, aefa_fate_op:bits_all(Arg0, EngineState)};

eval({'BITS_ALL_N' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:bits_all_n(Arg0, Arg1, EngineState)};

eval({'BITS_SET' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:bits_set(Arg0, Arg1, Arg2, EngineState)};

eval({'BITS_CLEAR' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:bits_clear(Arg0, Arg1, Arg2, EngineState)};

eval({'BITS_TEST' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:bits_test(Arg0, Arg1, Arg2, EngineState)};

eval({'BITS_SUM' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:bits_sum(Arg0, Arg1, EngineState)};

eval({'BITS_OR' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:bits_or(Arg0, Arg1, Arg2, EngineState)};

eval({'BITS_AND' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:bits_and(Arg0, Arg1, Arg2, EngineState)};

eval({'BITS_DIFF' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:bits_diff(Arg0, Arg1, Arg2, EngineState)};

eval({'ADDRESS' , Arg0}, EngineState) ->
    {next, aefa_fate_op:address(Arg0, EngineState)};

eval({'BALANCE' , Arg0}, EngineState) ->
    {next, aefa_fate_op:balance(Arg0, EngineState)};

eval({'ORIGIN' , Arg0}, EngineState) ->
    {next, aefa_fate_op:origin(Arg0, EngineState)};

eval({'CALLER' , Arg0}, EngineState) ->
    {next, aefa_fate_op:caller(Arg0, EngineState)};

eval({'GASPRICE' , Arg0}, EngineState) ->
    {next, aefa_fate_op:gasprice(Arg0, EngineState)};

eval({'BLOCKHASH' , Arg0}, EngineState) ->
    {next, aefa_fate_op:blockhash(Arg0, EngineState)};

eval({'BENEFICIARY' , Arg0}, EngineState) ->
    {next, aefa_fate_op:beneficiary(Arg0, EngineState)};

eval({'TIMESTAMP' , Arg0}, EngineState) ->
    {next, aefa_fate_op:timestamp(Arg0, EngineState)};

eval({'GENERATION' , Arg0}, EngineState) ->
    {next, aefa_fate_op:generation(Arg0, EngineState)};

eval({'MICROBLOCK' , Arg0}, EngineState) ->
    {next, aefa_fate_op:microblock(Arg0, EngineState)};

eval({'DIFFICULTY' , Arg0}, EngineState) ->
    {next, aefa_fate_op:difficulty(Arg0, EngineState)};

eval({'GASLIMIT' , Arg0}, EngineState) ->
    {next, aefa_fate_op:gaslimit(Arg0, EngineState)};

eval({'GAS' , Arg0}, EngineState) ->
    {next, aefa_fate_op:gas(Arg0, EngineState)};

eval({'LOG0' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:log(Arg0, Arg1, EngineState)};

eval({'LOG1' , Arg0, Arg1, Arg2}, EngineState) ->
    {next, aefa_fate_op:log(Arg0, Arg1, Arg2, EngineState)};

eval({'LOG2' , Arg0, Arg1, Arg2, Arg3}, EngineState) ->
    {next, aefa_fate_op:log(Arg0, Arg1, Arg2, Arg3, EngineState)};

eval({'LOG3' , Arg0, Arg1, Arg2, Arg3, Arg4}, EngineState) ->
    {next, aefa_fate_op:log(Arg0, Arg1, Arg2, Arg3, Arg4, EngineState)};

eval({'LOG4' , Arg0, Arg1, Arg2, Arg3, Arg4, Arg5}, EngineState) ->
    {next, aefa_fate_op:log(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, EngineState)};

eval('DEACTIVATE', EngineState) ->
    {next, aefa_fate_op:deactivate(EngineState)};

eval({'SPEND' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:spend(Arg0, Arg1, EngineState)};

eval({'ORACLE_REGISTER' , Arg0, Arg1, Arg2, Arg3, Arg4, Arg5}, EngineState) ->
    {next, aefa_fate_op:oracle_register(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, EngineState)};

eval('ORACLE_QUERY', EngineState) ->
    {next, aefa_fate_op:oracle_query(EngineState)};

eval('ORACLE_RESPOND', EngineState) ->
    {next, aefa_fate_op:oracle_respond(EngineState)};

eval('ORACLE_EXTEND', EngineState) ->
    {next, aefa_fate_op:oracle_extend(EngineState)};

eval('ORACLE_GET_ANSWER', EngineState) ->
    {next, aefa_fate_op:oracle_get_answer(EngineState)};

eval('ORACLE_GET_QUESTION', EngineState) ->
    {next, aefa_fate_op:oracle_get_question(EngineState)};

eval('ORACLE_QUERY_FEE', EngineState) ->
    {next, aefa_fate_op:oracle_query_fee(EngineState)};

eval('AENS_RESOLVE', EngineState) ->
    {next, aefa_fate_op:aens_resolve(EngineState)};

eval('AENS_PRECLAIM', EngineState) ->
    {next, aefa_fate_op:aens_preclaim(EngineState)};

eval('AENS_CLAIM', EngineState) ->
    {next, aefa_fate_op:aens_claim(EngineState)};

eval('AENS_UPDATE', EngineState) ->
    {next, aefa_fate_op:aend_update(EngineState)};

eval('AENS_TRANSFER', EngineState) ->
    {next, aefa_fate_op:aens_transfer(EngineState)};

eval('AENS_REVOKE', EngineState) ->
    {next, aefa_fate_op:aens_revoke(EngineState)};

eval('ECVERIFY', EngineState) ->
    {next, aefa_fate_op:ecverify(EngineState)};

eval('SHA3', EngineState) ->
    {next, aefa_fate_op:sha3(EngineState)};

eval('SHA256', EngineState) ->
    {next, aefa_fate_op:sha256(EngineState)};

eval('BLAKE2B', EngineState) ->
    {next, aefa_fate_op:blake2b(EngineState)};

eval({'BALANCE_OTHER' , Arg0, Arg1}, EngineState) ->
    {next, aefa_fate_op:balance_other(Arg0, Arg1, EngineState)};

eval({'SETELEMENT' , Arg0, Arg1, Arg2, Arg3}, EngineState) ->
    {next, aefa_fate_op:setelement(Arg0, Arg1, Arg2, Arg3, EngineState)};

eval({'DUMMY7ARG' , Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6}, EngineState) ->
    {next, aefa_fate_op:dummyarg(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, EngineState)};

eval({'DUMMY8ARG' , Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7}, EngineState) ->
    {next, aefa_fate_op:dummyarg(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, EngineState)};

eval({'ABORT' , Arg0}, EngineState) ->
    {next, aefa_fate_op:abort(Arg0, EngineState)};

eval({'EXIT' , Arg0}, EngineState) ->
    {next, aefa_fate_op:exit(Arg0, EngineState)};

eval('NOP', EngineState) ->
    {next, aefa_fate_op:nop(EngineState)};

eval(Op,_EngineState) ->
    throw({error, unknown_op, Op}).
