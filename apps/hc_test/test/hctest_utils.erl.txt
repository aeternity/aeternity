-module('hctest_utils.erl').

-include_lib("common_test/include/ct.hrl").
-include_lib("stdlib/include/assert.hrl").

-include("../include/hc_test.hrl").

-export([
%%    child_node_config/3,
%%    config_add_node/4,
%%    config_add_node1/1,
%%    config_add_node2/1,
%%    config_add_node3/1,
%%    contract_call/6,
%%    create_stub/1,
%%    decode_consensus_result/3,
%%    election_contract_address/0,
%%    encoded_pubkey/1,
%%    get_block_producer_name/2,
%%    get_generations/3,
%%    get_node_with_pubkey/2,
%%    get_nodes/1,
%%    mine_cc_blocks/2,
%%    mine_key_blocks/2,
%%    produce_cc_blocks/2,
%%    produce_cc_blocks/3,
%%    produce_n_epochs/2,
%%    set_remote_mining_delay/2,
%%    staking_contract_address/0,
%%    start_child_nodes/2,
%%    wait_same_top/3,
%%    with_saved_keys/2,
%%    stop_mining/1,
%%    get_height/1,
%%    get_cc_height_and_leader/1,
%%    double_spend/1
]).

start_child_nodes(Nodes, Config) ->
    NetworkId = binary_to_list(?config(network_id, Config)),
    StartNodeFn = fun(Node) ->
        {Node, NodeName, Stakers} = lists:keyfind(Node, 1, ?config(nodes, Config)),
        Env = [{"AE__FORK_MANAGEMENT__NETWORK_ID", NetworkId}],
        child_node_config(Node, Stakers, Config),
        aecore_suite_utils:start_node(Node, Config, Env),
        aecore_suite_utils:connect(NodeName, [])
    %%        aecore_suite_utils:rpc(Node, aec_db, install_test_env, [])
    end,
    lists:foreach(StartNodeFn, Nodes).

%% Retrieves configuration values from saved_config for specified keys and merges them into CT Config
%% See https://www.erlang.org/doc/apps/common_test/dependencies_chapter.html
with_saved_keys(Keys, Config) ->
    {_TC, SavedConfig} = ?config(saved_config, Config),
    lists:foldl(
        fun(Key, Conf) ->
            case proplists:get_value(Key, SavedConfig) of
                undefined -> Conf;
                Val -> [{Key, Val} | Conf]
            end
        end,
        lists:keydelete(saved_config, 1, Config),
        Keys
    ).

child_node_config(Node, Stakeholders, CTConfig) ->
    ReceiveAddress = encoded_pubkey(?FORD),
    Pinning = false,
    NodeConfig = node_config(Node, CTConfig, Stakeholders, ReceiveAddress, Pinning),
    build_json_files(?HC_CONTRACT, NodeConfig, CTConfig),
    aecore_suite_utils:create_config(Node, CTConfig, NodeConfig, [{add_peers, true}]).

pubkey({Pubkey, _, _}) -> Pubkey.

privkey({_, Privkey, _}) -> Privkey.

encoded_pubkey(Who) ->
    aeser_api_encoder:encode(account_pubkey, pubkey(Who)).

src(ContractName, Config) ->
    Srcs = ?config(contract_src, Config),
    maps:get(ContractName, Srcs).

node_config(Node, CTConfig, PotentialStakers, ReceiveAddress, ProducingCommitments) ->
    NetworkId = ?config(network_id, CTConfig),
    GenesisStartTime = ?config(genesis_start_time, CTConfig),
    Stakers = lists:map(
        fun(HCWho) ->
            %% TODO: discuss key management
            HCPriv = list_to_binary(aeu_hex:bin_to_hex(privkey(HCWho))),
            #{
                <<"hyper_chain_account">> => #{
                    <<"pub">> => encoded_pubkey(HCWho), <<"priv">> => HCPriv
                }
            }
        end,
        PotentialStakers
    ),
    ConsensusType = <<"hyperchain">>,
    Port = aecore_suite_utils:external_api_port(?PARENT_CHAIN_NODE),
    SpecificConfig =
        #{
            <<"parent_chain">> =>
                #{
                    <<"start_height">> => ?config(parent_start_height, CTConfig),
                    <<"finality">> => ?PARENT_FINALITY,
                    <<"parent_epoch_length">> => ?PARENT_EPOCH_LENGTH,
                    <<"consensus">> =>
                        #{
                            <<"type">> => <<"AE2AE">>,
                            <<"network_id">> => ?PARENT_CHAIN_NETWORK_ID,
                            <<"spend_address">> => ReceiveAddress,
                            <<"fee">> => 100000000000000,
                            <<"amount">> => 9700
                        },
                    <<"polling">> =>
                        #{
                            <<"fetch_interval">> => 100,
                            <<"cache_size">> => 10,
                            <<"nodes">> => [
                                iolist_to_binary(
                                    io_lib:format("http://test:Pass@127.0.0.1:~p", [Port])
                                )
                            ]
                        },
                    <<"producing_commitments">> => ProducingCommitments
                },
            <<"genesis_start_time">> => GenesisStartTime,
            <<"child_epoch_length">> => ?CHILD_EPOCH_LENGTH,
            <<"child_block_time">> => ?CHILD_BLOCK_TIME
        },
    Protocol = aect_test_utils:latest_protocol_version(),
    {ok, ContractFileName} = aecore_suite_utils:hard_fork_filename(
        Node, CTConfig, integer_to_list(Protocol), binary_to_list(NetworkId) ++ "_contracts.json"
    ),
    {ok, AccountFileName} = aecore_suite_utils:hard_fork_filename(
        Node, CTConfig, integer_to_list(Protocol), binary_to_list(NetworkId) ++ "_accounts.json"
    ),
    #{
        <<"chain">> =>
            #{
                <<"persist">> => false,
                <<"hard_forks">> => #{
                    integer_to_binary(Protocol) => #{
                        <<"height">> => 0,
                        <<"contracts_file">> => ContractFileName,
                        <<"accounts_file">> => AccountFileName
                    }
                },
                <<"consensus">> =>
                    #{
                        <<"0">> => #{
                            <<"type">> => ConsensusType,
                            <<"config">> =>
                                maps:merge(
                                    #{
                                        <<"election_contract">> => aeser_api_encoder:encode(
                                            contract_pubkey, election_contract_address()
                                        ),
                                        <<"rewards_contract">> => aeser_api_encoder:encode(
                                            contract_pubkey, staking_contract_address()
                                        ),
                                        <<"staking_contract">> => aeser_api_encoder:encode(
                                            contract_pubkey, staking_contract_address()
                                        ),
                                        <<"contract_owner">> => aeser_api_encoder:encode(
                                            account_pubkey, ?OWNER_PUBKEY
                                        ),
                                        <<"expected_key_block_rate">> => 2000,
                                        <<"stakers">> => Stakers,
                                        <<"pinning_reward_value">> => 4711
                                    },
                                    SpecificConfig
                                )
                        }
                    }
            },
        <<"fork_management">> =>
            #{<<"network_id">> => <<"this_will_be_overwritten_runtime">>},
        <<"logging">> => #{<<"level">> => <<"debug">>},
        <<"sync">> => #{<<"ping_interval">> => 5000},
        <<"http">> => #{<<"endpoints">> => #{<<"hyperchain">> => true}},
        <<"mining">> =>
            #{
                <<"micro_block_cycle">> => 1,
                <<"autostart">> => false,
                %%<<"autostart">> => ProducingCommitments,
                <<"beneficiary_reward_delay">> => ?REWARD_DELAY
            }
    }.

build_json_files(ElectionContract, NodeConfig, CTConfig) ->
    Pubkey = ?OWNER_PUBKEY,
    {_PatronPriv, PatronPub} = aecore_suite_utils:sign_keys(?NODE1),
    ct:log("Patron is ~p", [aeser_api_encoder:encode(account_pubkey, PatronPub)]),
    EncodePub =
        fun(P) ->
            binary_to_list(aeser_api_encoder:encode(account_pubkey, P))
        end,
    %% create staking contract

    %% 1 mln AE
    MinValidatorAmt = integer_to_list(trunc(math:pow(10, 18) * math:pow(10, 6))),
    %% 1 AE
    MinStakeAmt = integer_to_list(trunc(math:pow(10, 18) * 1)),
    MinStakePercent = "30",
    OnlineDelay = "0",
    StakeDelay = "0",
    UnstakeDelay = "0",
    #{<<"pubkey">> := StakingValidatorContract} =
        C0 =
        contract_create_spec(
            "StakingValidator",
            src("StakingValidator", CTConfig),
            [EncodePub(Pubkey), UnstakeDelay],
            0,
            1,
            Pubkey
        ),
    {ok, ValidatorPoolAddress} = aeser_api_encoder:safe_decode(
        contract_pubkey,
        StakingValidatorContract
    ),
    %% assert assumption
    ValidatorPoolAddress = validator_pool_contract_address(),
    MSSrc = src(?MAIN_STAKING_CONTRACT, CTConfig),
    #{
        <<"pubkey">> := StakingContractPubkey,
        <<"owner_pubkey">> := ContractOwner
    } =
        SC =
        contract_create_spec(
            ?MAIN_STAKING_CONTRACT,
            MSSrc,
            [
                binary_to_list(StakingValidatorContract),
                MinValidatorAmt,
                MinStakePercent,
                MinStakeAmt,
                OnlineDelay,
                StakeDelay,
                UnstakeDelay
            ],
            0,
            2,
            Pubkey
        ),
    {ok, StakingAddress} = aeser_api_encoder:safe_decode(
        contract_pubkey,
        StakingContractPubkey
    ),
    %% assert assumption
    StakingAddress = staking_contract_address(),
    %% create election contract
    #{
        <<"pubkey">> := ElectionContractPubkey,
        <<"owner_pubkey">> := ContractOwner
    } =
        EC =
        contract_create_spec(
            ElectionContract,
            src(ElectionContract, CTConfig),
            [binary_to_list(StakingContractPubkey)],
            0,
            3,
            Pubkey
        ),
    {ok, ElectionAddress} = aeser_api_encoder:safe_decode(
        contract_pubkey,
        ElectionContractPubkey
    ),
    %% assert assumption
    ElectionAddress = election_contract_address(),
    {ok, SCId} = aeser_api_encoder:safe_decode(
        contract_pubkey,
        StakingContractPubkey
    ),
    Call1 =
        contract_call_spec(
            SCId,
            MSSrc,
            "new_validator",
            [],
            ?INITIAL_STAKE,
            pubkey(?ALICE),
            1
        ),
    Call2 =
        contract_call_spec(
            SCId,
            MSSrc,
            "new_validator",
            [],
            ?INITIAL_STAKE,
            pubkey(?BOB),
            1
        ),
    Call3 =
        contract_call_spec(
            SCId,
            MSSrc,
            "new_validator",
            [],
            ?INITIAL_STAKE,
            pubkey(?LISA),
            1
        ),
    Call4 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_online",
            [],
            0,
            pubkey(?ALICE),
            2
        ),
    Call5 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_online",
            [],
            0,
            pubkey(?BOB),
            2
        ),
    Call6 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_online",
            [],
            0,
            pubkey(?LISA),
            2
        ),
    Call7 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_validator_name",
            ["\"Alice\""],
            0,
            pubkey(?ALICE),
            3
        ),
    Call8 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_validator_name",
            ["\"Bob\""],
            0,
            pubkey(?BOB),
            3
        ),
    Call9 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_validator_name",
            ["\"Lisa\""],
            0,
            pubkey(?LISA),
            3
        ),
    Call10 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_validator_description",
            [
                "\"Alice is a really awesome validator and she had set a description of her great service to the work.\""
            ],
            0,
            pubkey(?ALICE),
            4
        ),
    Call11 =
        contract_call_spec(
            SCId,
            MSSrc,
            "set_validator_avatar_url",
            ["\"https://aeternity.com/images/aeternity-logo.svg\""],
            0,
            pubkey(?ALICE),
            5
        ),

    %% create a BRI validator in the contract so they can receive
    %% rewards as well
    %% TODO: discuss how we want to tackle this:
    %%  A) require the BRI account to be validator
    %%  B) allow pending stake in the contract that is not allocated
    %%  yet
    %%  C) something else
    %% Call12 =
    %%     contract_call_spec(SCId, MSSrc,
    %%                         "new_validator", [],
    %%                         ?INITIAL_STAKE, BRIPub, 1),
    %% Call13 =
    %%     contract_call_spec(SCId, MSSrc,
    %%                         "set_validator_description",
    %%                         ["\"This validator is offline. She can never become a leader. She has no name set. She is receiving the BRI rewards\""],
    %%                         0, BRIPub, 2),
    %% keep the BRI offline
    AllCalls = [
        Call1,
        Call2,
        Call3,
        Call4,
        Call5,
        Call6,
        Call7,
        Call8,
        Call9,
        Call10,
        Call11
    ],
    ProtocolBin = integer_to_binary(aect_test_utils:latest_protocol_version()),
    #{
        <<"chain">> := #{
            <<"hard_forks">> := #{
                ProtocolBin := #{
                    <<"contracts_file">> := ContractsFileName,
                    <<"accounts_file">> := AccountsFileName
                }
            }
        }
    } = NodeConfig,
    aecore_suite_utils:create_seed_file(
        ContractsFileName,
        #{<<"contracts">> => [C0, SC, EC], <<"calls">> => AllCalls}
    ),
    aecore_suite_utils:create_seed_file(
        AccountsFileName,
        #{
            <<"ak_2evAxTKozswMyw9kXkvjJt3MbomCR1nLrf91BduXKdJLrvaaZt">> =>
                1000000000000000000000000000000000000000000000000,
            encoded_pubkey(?ALICE) => 2100000000000000000000000000,
            encoded_pubkey(?BOB) => 3100000000000000000000000000,
            encoded_pubkey(?LISA) => 4100000000000000000000000000
        }
    ),
    ok.

validator_pool_contract_address() ->
    aect_contracts:compute_contract_pubkey(?OWNER_PUBKEY, 1).

staking_contract_address() ->
    aect_contracts:compute_contract_pubkey(?OWNER_PUBKEY, 2).

election_contract_address() ->
    aect_contracts:compute_contract_pubkey(?OWNER_PUBKEY, 3).

contract_create_spec(Name, Src, Args, Amount, Nonce, Owner) ->
    {ok, Code} = aect_test_utils:compile_contract(aect_test_utils:sophia_version(), Name),
    Pubkey = aect_contracts:compute_contract_pubkey(Owner, Nonce),
    EncodedPubkey = aeser_api_encoder:encode(contract_pubkey, Pubkey),
    EncodedOwner = aeser_api_encoder:encode(account_pubkey, Owner),
    EncodedCode = aeser_api_encoder:encode(contract_bytearray, Code),
    {ok, CallData} = aect_test_utils:encode_call_data(Src, "init", Args),
    EncodedCallData = aeser_api_encoder:encode(contract_bytearray, CallData),
    VM = aect_test_utils:vm_version(),
    ABI = aect_test_utils:abi_version(),
    Spec = #{
        <<"amount">> => Amount,
        <<"vm_version">> => VM,
        <<"abi_version">> => ABI,
        <<"nonce">> => Nonce,
        <<"code">> => EncodedCode,
        <<"call_data">> => EncodedCallData,
        <<"pubkey">> => EncodedPubkey,
        <<"owner_pubkey">> => EncodedOwner
    },
    Spec.

contract_call_spec(ContractPubkey, Src, Fun, Args, Amount, From, Nonce) ->
    {contract_call_tx, CallTx} =
        aetx:specialize_type(
            contract_call(
                ContractPubkey,
                Src,
                Fun,
                Args,
                Amount,
                From,
                Nonce
            )
        ),
    %% Don't allow named contracts!?
    {contract, ContractPubKey} =
        aeser_id:specialize(aect_call_tx:contract_id(CallTx)),
    Spec =
        #{
            <<"caller">> => aeser_api_encoder:encode(
                account_pubkey,
                aect_call_tx:caller_pubkey(CallTx)
            ),
            <<"nonce">> => aect_call_tx:nonce(CallTx),
            <<"contract_pubkey">> => aeser_api_encoder:encode(contract_pubkey, ContractPubKey),
            <<"abi_version">> => aect_call_tx:abi_version(CallTx),
            <<"fee">> => aect_call_tx:fee(CallTx),
            <<"amount">> => aect_call_tx:amount(CallTx),
            <<"gas">> => aect_call_tx:gas(CallTx),
            <<"gas_price">> => aect_call_tx:gas_price(CallTx),
            <<"call_data">> => aeser_api_encoder:encode(
                contract_bytearray,
                aect_call_tx:call_data(CallTx)
            )
        },
    Spec.

contract_call(ContractPubkey, Src, Fun, Args, Amount, From) ->
    %% no contract calls support for parent chain
    Nonce = next_nonce(?NODE1, From),
    contract_call(ContractPubkey, Src, Fun, Args, Amount, From, Nonce).

contract_call(ContractPubkey, Src, Fun, Args, Amount, From, Nonce) ->
    {ok, CallData} = aect_test_utils:encode_call_data(Src, Fun, Args),
    ABI = aect_test_utils:abi_version(),
    TxSpec =
        #{
            caller_id => aeser_id:create(account, From),
            nonce => Nonce,
            contract_id => aeser_id:create(contract, ContractPubkey),
            abi_version => ABI,
            fee => 1000000 * ?DEFAULT_GAS_PRICE,
            amount => Amount,
            gas => 1000000,
            gas_price => ?DEFAULT_GAS_PRICE,
            call_data => CallData
        },
    {ok, Tx} = aect_call_tx:new(TxSpec),
    Tx.

decode_consensus_result(Call, Fun, Src) ->
    ReturnType = aect_call:return_type(Call),
    ReturnValue = aect_call:return_value(Call),
    Res = aect_test_utils:decode_call_result(Src, Fun, ReturnType, ReturnValue),
    {ReturnType, Res}.

next_nonce(Node, Pubkey) ->
    case aecore_suite_utils:rpc(Node, aec_next_nonce, pick_for_account, [Pubkey, max]) of
        {ok, NextNonce} -> NextNonce;
        {error, account_not_found} -> 1
    end.

create_stub(ContractFile) ->
    create_stub(ContractFile, []).

create_stub(ContractFile, Opts) ->
    {ok, Enc} = aeso_aci:contract_interface(json, ContractFile, Opts ++ [{no_code, true}]),
    {ok, Stub} = aeso_aci:render_aci_json(Enc),
    binary_to_list(Stub).

%% Increase the child chain with a number of key blocks. Automatically add key blocks on parent chain and
%% if there are Txs, put them in a micro block.
-type produce_cc_blocks_options() :: #{
    skip_nodes => list(node()),
    producer => node()
}.
-spec produce_cc_blocks(
    Config :: ct_config(), BlocksCnt :: pos_integer(), Options :: produce_cc_blocks_options()
) -> {ok, [_Block]}.
produce_cc_blocks(Config, BlocksCnt) ->
    produce_cc_blocks(Config, BlocksCnt, #{}).

produce_cc_blocks(Config, BlocksCnt, Options) ->
    SkipNodes = maps:get(skip_nodes, Options, []),
    Nodes = get_nodes(Config) -- SkipNodes,
    Node1 = maps:get(producer, Options, hd(Nodes)),

    TopHeight = aecore_suite_utils:rpc(Node1, aec_chain, top_height, []),
    {ok, #{epoch := Epoch, first := First, last := Last, length := L} = Info} =
        aecore_suite_utils:rpc(Node1, aec_chain_hc, epoch_info, [TopHeight]),
    ct:log("EpochInfo ~p", [Info]),

    %% At end of BlocksCnt child epoch approaches approx:
    CBAfterEpoch = BlocksCnt - (Last - TopHeight),
    ScheduleUpto = Epoch + 1 + (CBAfterEpoch div L),
    ParentTopHeight = aecore_suite_utils:rpc(?PARENT_CHAIN_NODE, aec_chain, top_height, []),
    ct:log("P@~p C@~p for next ~p child blocks", [ParentTopHeight, TopHeight, BlocksCnt]),

    %% Spread parent blocks over BlocksCnt
    ParentProduce =
        lists:append([
            spread(
                ?PARENT_EPOCH_LENGTH,
                TopHeight,
                [{CH, 0} || CH <- lists:seq(First + E * L, Last + E * L)]
            )
         || E <- lists:seq(0, ScheduleUpto - Epoch)
        ]),
    %% Last parameter steers where in Child epoch parent block is produced
    produce_cc_blocks_(Config, BlocksCnt, ParentProduce, Options).

-spec produce_cc_blocks_(
    Config :: ct_config(),
    BlocksCnt :: pos_integer(),
    ParentProduce :: list(),
    Options :: produce_cc_blocks_options()
) -> {ok, [_Block]}.
produce_cc_blocks_(Config, BlocksCnt, ParentProduce, Options) ->
    SkipNodes = maps:get(skip_nodes, Options, []),
    Nodes = get_nodes(Config) -- SkipNodes,
    Node1 = maps:get(producer, Options, hd(Nodes)),

    %% The previous production ended with wait_same_top, so asking first node is sufficient
    TopHeight = aecore_suite_utils:rpc(Node1, aec_chain, top_height, []),

    %% assert that the parent chain is not mining
    %% elp:ignore W0014 (cross_node_eval)
    ?assertEqual(
        stopped,
        rpc:call(?PARENT_CHAIN_NODE_NAME, aec_conductor, get_mining_state, []),
        "Parent chain node has to have mining stopped"
    ),
    ct:log("produce_cc_blocks: parent produce ~0p", [ParentProduce]),

    NewTopHeight = produce_to_cc_height(
        Config, TopHeight, TopHeight + BlocksCnt, ParentProduce, #{skip_nodes => SkipNodes}
    ),
    wait_same_top(
        get_nodes(Config),
        3,
        #{skip_nodes => SkipNodes}
    ),
    get_generations(Node1, TopHeight + 1, NewTopHeight).

set_remote_mining_delay(Nodes, _Delay) ->
    lists:foreach(
        fun({_N, _, _}) ->
            %% TODO: Figure out the correct table name and key name
            %% rpc(N, aeu_ets_cache, put, [?ETS_CACHE_TABLE, child_block_time, Delay])
            ?assert(false, "Not implemented")
        end,
        Nodes
    ).

%% It seems we automatically produce child chain blocks in the background
-spec produce_to_cc_height(
    Config :: ct_config(),
    TopHeight :: non_neg_integer(),
    GoalHeight :: non_neg_integer(),
    ParentProduce :: list(),
    Options :: produce_cc_blocks_options()
) -> non_neg_integer().
produce_to_cc_height(Config, TopHeight, GoalHeight, ParentProduce, Options) ->
    SkipNodes = maps:get(skip_nodes, Options, []),
    NodeNames = [
        NodeName
     || {Node, NodeName, _} <- ?config(nodes, Config), not lists:member(Node, SkipNodes)
    ],

    Producer = maps:get(producer, Options, hd(NodeNames)),
    ct:pal("produce_to_cc_height: nodeNames=~0p skipNodes=~0p producer=~s", [
        NodeNames, SkipNodes, Producer
    ]),

    BlocksNeeded = GoalHeight - TopHeight,
    case BlocksNeeded > 0 of
        false ->
            TopHeight;
        true ->
            NewParentProduce =
                case ParentProduce of
                    [{CH, PBs} | PRest] when CH == TopHeight + 1 ->
                        mine_key_blocks(?PARENT_CHAIN_NODE_NAME, PBs),
                        PRest;
                    PP ->
                        PP
                end,
            KeyBlock =
                % elp:ignore W0014 (cross_node_eval)
                case rpc:call(Producer, aec_tx_pool, peek, [infinity]) of
                    {ok, []} ->
                        {ok, [{N, Block}]} = mine_cc_blocks(NodeNames, 1),
                        ct:log("CC node-~p mined key block only:~n~p", [N, Block]),
                        Block;
                    {ok, _Txs} ->
                        {ok, [{N1, KB}, {N2, MB}]} = mine_cc_blocks(NodeNames, 2),
                        ?assertEqual(key, aec_blocks:type(KB), "Block is not 'key' block"),
                        ?assertEqual(micro, aec_blocks:type(MB), "Block is not 'micro' block"),
                        ct:log("CC node=~p mined micro block:~n~p", [N2, MB]),
                        ct:log("+ CC node=~p mined key block:~n~p", [N1, KB]),
                        KB
                end,
            ProducerName = get_block_producer_name(?config(staker_names, Config), KeyBlock),
            ct:log("~p produced CC block at height ~p", [ProducerName, aec_blocks:height(KeyBlock)]),
            produce_to_cc_height(Config, TopHeight + 1, GoalHeight, NewParentProduce, #{
                skip_nodes => SkipNodes
            })
    end.

mine_cc_blocks(NodeNames, N) ->
    aecore_suite_utils:hc_mine_blocks(NodeNames, N).

stop_mining(Nodes) ->
    lists:foreach(fun(Node) -> ok = rpc:call(Node, aec_conductor, stop_mining, []) end, Nodes).

get_generations(Node, FromHeight, ToHeight) ->
    ReversedBlocks =
        lists:foldl(
            fun(Height, Accum) ->
                case
                    aecore_suite_utils:rpc(Node, aec_chain, get_generation_by_height, [
                        Height, forward
                    ])
                of
                    {ok, #{key_block := KB, micro_blocks := MBs}} ->
                        ReversedGeneration = lists:reverse(MBs) ++ [KB],
                        ReversedGeneration ++ Accum;
                    error ->
                        error({failed_to_fetch_generation, Height})
                end
            end,
            [],
            lists:seq(FromHeight, ToHeight)
        ),
    {ok, lists:reverse(ReversedBlocks)}.

mine_key_blocks(ParentNodeName, NumParentBlocks) ->
    {ok, _} = aecore_suite_utils:mine_micro_block_emptying_mempool_or_fail(ParentNodeName),
    {ok, KBs} = aecore_suite_utils:mine_key_blocks(ParentNodeName, NumParentBlocks),
    ct:log("Parent block mined ~p ~p number: ~p", [KBs, ParentNodeName, NumParentBlocks]),
    {ok, KBs}.

%get_block_producer_name(Parties, Node, Height) ->
%    Producer = get_block_producer(Node, Height),
%    case lists:keyfind(Producer, 1, Parties) of
%        false -> Producer;
%        {_, _, Name} -> Name
%    end.

get_block_producer_name(Parties, Block) ->
    Producer = aec_blocks:miner(Block),
    case lists:keyfind(Producer, 1, Parties) of
        false -> Producer;
        {_, _, Name} -> Name
    end.

spread(_, _, []) ->
    [];
spread(0, TopHeight, Spread) ->
    [{CH, N} || {CH, N} <- Spread, N /= 0, CH > TopHeight];
%spread(N, TopHeight, [{CH, K} | Spread]) when length(Spread) < N ->
%    %% Take speed first (not realistic), then fill rest
%    spread(0, TopHeight, [{CH, K + N - length(Spread)} | [ {CH2, X+1} || {CH2, X} <- Spread]]);
spread(N, TopHeight, Spread) when N rem 2 == 0 ->
    {Left, Right} = lists:split(length(Spread) div 2, Spread),
    spread(N div 2, TopHeight, Left) ++ spread(N div 2, TopHeight, Right);
spread(N, TopHeight, Spread) when N rem 2 == 1 ->
    {Left, [{Middle, K} | Right]} = lists:split(length(Spread) div 2, Spread),
    spread(N div 2, TopHeight, Left) ++ [{Middle, K + 1} || Middle > TopHeight] ++
        spread(N div 2, TopHeight, Right).

%% Wait for multiple nodes reaching same height/top block, options allow to
%% ignore some nodes (which are offline due to the test stopping them)
wait_same_top(_Nodes, Attempts, _Options) when Attempts < 1 ->
    {error, run_out_of_attempts};
wait_same_top(Nodes, Attempts, Options) ->
    SkipNodes = maps:get(skip_nodes, Options, []),
    KBs = [
        aecore_suite_utils:rpc(Node, aec_chain, top_block, [])
     || Node <- (Nodes -- SkipNodes)
    ],
    case lists:usort(KBs) of
        [KB] ->
            {ok, KB};
        Diffs ->
            ct:log("wait_same_top: Nodes differ ~p", [Diffs]),
            timer:sleep(?CHILD_BLOCK_TIME div 2),
            wait_same_top(Nodes, Attempts - 1, Options)
    end.

config_add_node(Config0, Node, NodeName, Stakers) ->
    Nodes0 = proplists:get_value(nodes, Config0, []),
    Nodes1 = [{Node, NodeName, Stakers} | Nodes0],
    Config1 = proplists:delete(nodes, Config0),
    [{nodes, Nodes1} | Config1].

config_add_node1(Config) ->
    config_add_node(Config, ?NODE1, ?NODE1_NAME, [?ALICE]).

config_add_node2(Config) ->
    config_add_node(Config, ?NODE2, ?NODE2_NAME, [?BOB]).

config_add_node3(Config) ->
    config_add_node(Config, ?NODE3, ?NODE3_NAME, [?LISA]).

-type produce_epoch_options() :: #{
    count_epochs => pos_integer(),
    %% Do not produce final block of the last epoch
    unfinished => boolean()
}.
-spec produce_n_epochs(Config :: proplists:proplist(), Options :: produce_epoch_options()) -> ok.
produce_n_epochs(Config, #{count_epochs := NumEpochs} = Options) ->
    Unfinished = maps:get(unfinished, Options, false),
    [{Node1, _, _} | _] = ?config(nodes, Config),
    %% produce blocks. Optionally do not produce last block of the last epoch
    {ok, Bs} = produce_cc_blocks(
        Config,
        NumEpochs * ?CHILD_EPOCH_LENGTH -
            case Unfinished of
                true -> 1;
                _ -> 0
            end
    ),
    %% check producers
    %% TODO: Unfinished set to true should relax these asserts
    Producers = [aec_blocks:miner(B) || B <- Bs],
    ChildTopHeight = aecore_suite_utils:rpc(Node1, aec_chain, top_height, []),
    Leaders = leaders_at_height(Node1, ChildTopHeight, Config),
    ct:log("Bs: ~p  Leaders ~p", [Bs, Leaders]),
    %% Check that all producers are valid leaders
    ?assertEqual(
        [],
        lists:usort(Producers) -- Leaders,
        "Only leader nodes should be the producers of the mined blocks"
    ),
    %% If we have more than 1 leader, then we should see more than one producer
    %% at least for larger EPOCHs
    ?assert(
        length(Leaders) > 1 andalso length(Producers) > 1,
        "Having more than one leader must also have more than one producer"
    ),
    ParentTopHeight = aecore_suite_utils:rpc(?PARENT_CHAIN_NODE, aec_chain, top_height, []),
    {ok, ParentBlocks} = get_generations(?PARENT_CHAIN_NODE, 0, ParentTopHeight),
    ct:log("Parent chain blocks ~p", [ParentBlocks]),
    {ok, ChildBlocks} = get_generations(Node1, 0, ChildTopHeight),
    ct:log("Child chain blocks ~p", [ChildBlocks]),
    ok.

leaders_at_height(Node, Height, Config) ->
    {ok, Hash} = aecore_suite_utils:rpc(Node, aec_chain_state, get_key_block_hash_at_height, [
        Height
    ]),
    {ok, Return} = inspect_staking_contract(?ALICE, leaders, Config, Hash),
    [
        begin
            {account_pubkey, K} = aeser_api_encoder:decode(LeaderKey),
            K
        end
     || [LeaderKey, _LeaderStake] <- Return
    ].

inspect_staking_contract(OriginWho, WhatToInspect, Config) ->
    TopHash = aecore_suite_utils:rpc(?NODE1, aec_chain, top_block_hash, []),
    inspect_staking_contract(OriginWho, WhatToInspect, Config, TopHash).

inspect_staking_contract(OriginWho, WhatToInspect, Config, TopHash) ->
    {Fun, Args} =
        case WhatToInspect of
            {staking_power, Who} ->
                {"staking_power", [binary_to_list(encoded_pubkey(Who))]};
            {get_validator_state, Who} ->
                {"get_validator_state", [binary_to_list(encoded_pubkey(Who))]};
            get_state ->
                {"get_state", []};
            leaders ->
                {"sorted_validators", []}
        end,
    ContractPubkey = ?config(staking_contract, Config),
    do_contract_call(
        ContractPubkey, src(?MAIN_STAKING_CONTRACT, Config), Fun, Args, OriginWho, TopHash
    ).

inspect_election_contract(OriginWho, WhatToInspect, Config) ->
    TopHash = aecore_suite_utils:rpc(?NODE1, aec_chain, top_block_hash, []),
    inspect_election_contract(OriginWho, WhatToInspect, Config, TopHash).

inspect_election_contract(OriginWho, WhatToInspect, Config, TopHash) ->
    {Fun, Args} =
        case WhatToInspect of
            current_added_staking_power -> {"added_stake", []}
        end,
    ContractPubkey = ?config(election_contract, Config),
    do_contract_call(ContractPubkey, src(?HC_CONTRACT, Config), Fun, Args, OriginWho, TopHash).

do_contract_call(CtPubkey, CtSrc, Fun, Args, Who, TopHash) ->
    F = fun() -> do_contract_call_(CtPubkey, CtSrc, Fun, Args, Who, TopHash) end,
    {T, Res} = timer:tc(F),
    ct:log("Calling contract took ~.2f ms", [T / 1000]),
    Res.

do_contract_call_(CtPubkey, CtSrc, Fun, Args, Who, TopHash) ->
    Tx = contract_call(CtPubkey, CtSrc, Fun, Args, 0, pubkey(Who)),
    {ok, Call} = dry_run(TopHash, Tx),
    decode_consensus_result(Call, Fun, CtSrc).

dry_run(TopHash, Tx) ->
    case aecore_suite_utils:rpc(?NODE1, aec_dry_run, dry_run, [TopHash, [], [{tx, Tx}]]) of
        {error, _} = Err -> Err;
        {ok, {[{contract_call_tx, {ok, Call}}], _Events}} -> {ok, Call}
    end.

get_nodes(Config) ->
    [Node || {Node, _, _} <- proplists:get_value(nodes, Config)].

accounts_countains_pubkey(Accounts, Pubkey) ->
    lists:any(fun({Pub, _Priv, _AccountName}) -> Pub =:= Pubkey end, Accounts).

get_node_with_pubkey(Pubkey, Config) ->
    NodeTriples = ?config(nodes, Config),
    Nodes = [Node || {Node, _, _Accounts} <- NodeTriples],
    case
        [Node || {Node, _, Accounts} <- NodeTriples, accounts_countains_pubkey(Accounts, Pubkey)]
    of
        [] -> ct:fail("Can't find node with pubkey=~0p nodes=~0p", [Pubkey, Nodes]);
        [One] -> One;
        _Many -> ct:fail("Found multiple nodes with pubkey=~0p nodes=~0p", [Pubkey, Nodes])
    end.

% node_name(Node, Config) ->
%     {Node, NodeName, _Stakers} = lists:keyfind(Node, 1, ?config(nodes, Config)),
%     NodeName.

% node_pubkey(Node, Config) ->
%     {Node, NodeName, _Stakers} = lists:keyfind(Node, 1, ?config(nodes, Config)),
%     NodeName.

% find_peer(OnNode, Node) ->
%     AllPeers = aecore_suite_utils:rpc(OnNode, aec_peers, available_peers, []),
%     lists:keyfind(PeerToBlock, #peer.pubkey, AllPeers).

% block_peer(OnNode, PeerToBlock) ->
%     Peer = find_peer(OnNode, PeerToBlock),
%     aecore_suite_utils:rpc(OnNode, aec_peers, block_peer, [PeerToBlock]).

% unblock_peer(OnNode, PeerToUnblock) ->
%     aecore_suite_utils:rpc(OnNode, aec_peers, unblock_peer, [PeerToUnblock]).

%% Disconnect the gossip protocol and stop the production activity
% node3_disappear(DisappearingNode, Config) ->
%     catch aecore_suite_utils:stop_node(?NODE3, Config).
% aecore_suite_utils:rpc(DisappearingNode, aec_conductor, stop_mining, []),
% OtherNodes = lists:filter(
%     fun(N) -> N =/= DisappearingNode end,
%     get_nodes(Config)
% ),
% lists:foreach(
%     fun(N) ->
%         aecore_suite_utils:rpc(N, aec_peers, block_peer, [find_peer(DisappearingNode)]),
%         aecore_suite_utils:rpc(DisappearingNode, aec_peers, block_peer, [find_peer(N)])
%     end,
%     OtherNodes
% ),
% ok.

%% Reconnect the gossip protocol and start the production activity
% node_reappear(ReappearingNode, Config) ->
%     OtherNodes = lists:filter(
%         fun(N) -> N =/= ReappearingNode end,
%         get_nodes(Config)
%     ),
%     lists:foreach(
%         fun(N) ->
%             aecore_suite_utils:rpc(N, aec_peers, unblock_peer, [find_peer(ReappearingNode)]),
%             aecore_suite_utils:rpc(ReappearingNode, aec_peers, unblock_peer, [find_peer(N)])
%         end,
%         OtherNodes
%     ),
%     aecore_suite_utils:rpc(ReappearingNode, aec_conductor, start_mining, []),
%     ok.

get_height(Node) ->
    aecore_suite_utils:rpc(Node, aec_chain, top_height, []).

get_cc_height_and_leader(Config) ->
    {Node1, _, _} = hd(proplists:get_value(nodes, Config)),
    Height = get_height(Node1),
    {ok, LeaderPubkey} = aecore_suite_utils:rpc(Node1, aec_consensus_hc, leader_for_height, [
        Height
    ]),
    Leader = 'hctest_utils.erl':get_node_with_pubkey(LeaderPubkey, Config),
    {Height, Leader}.

%% @doc Interfere with the mining process in a way such that produces two valid blocks
%% from the same tophash and publishes both.
double_spend(Node) ->
    ok = aecore_suite_utils:rpc(Node, aec_conductor, stop_mining, []),
    ?assertEqual(
        stopped,
        aecore_suite_utils:rpc(Node, aec_conductor, get_mining_state, []),
        "Mining must be stopped on Node before attempting to fork"
    ),
    ConductorState = aecore_suite_utils:rpc(Node, sys, get_state, [aec_conductor]),
    aecore_suite_utils:rpc(Node, aec_conductor, create_key_block_candidate, [ConductorState]),
    aecore_suite_utils:rpc(Node, aec_conductor, create_key_block_candidate, [ConductorState]),
    ok.
