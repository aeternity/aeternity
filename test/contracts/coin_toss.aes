include "String.aes"

contract CoinToss =
  record state = { casino          : address,
                   player          : address,
                   hash            : option(hash),
                   height          : int,
                   player_pick     : option(string),
                   stake    : int,
                   reaction_time   : int
                   }

  entrypoint init(casino: address, player: address, reaction_time: int) : state =
    require(Call.value == 0, "no_deposit")
    { casino          = casino,
      player          = player,
      hash            = None,
      height          = 0,
      player_pick     = None,
      stake    = 0,
      reaction_time   = reaction_time
      }

  payable stateful entrypoint provide_hash(hash: hash) =
    require_casino()
    require(state.hash == None, "already_has_hash")
    put(state{ hash = Some(hash),
               stake = Call.value,
               height = Chain.block_height})

  payable stateful entrypoint player_pick(coin_side: string) =
    require_player()
    ensure_player_turn_to_pick()
    ensure_coin_side(coin_side)
    require(Call.value == state.stake, "wrong_stake")
    put(state{ player_pick  = Some(coin_side),
               height       = Chain.block_height})

  stateful entrypoint reveal(key: string, coin_side: string) =
    require_casino()
    ensure_casino_turn_to_reveal()
    ensure_coin_side(coin_side)
    ensure_if_key_is_valid(key, coin_side)
    let Some(player_pick) = state.player_pick
    if (coin_side == player_pick)
      Chain.spend(state.player, Contract.balance)
    else
      Chain.spend(state.casino, Contract.balance)
    reset_state()

  stateful entrypoint player_dispute_no_reveal() =
    require_player()
    ensure_casino_turn_to_reveal()
    require(state.height  + state.reaction_time < Chain.block_height, "not_yet_allowed")
    Chain.spend(state.player, Contract.balance)
    reset_state()

  stateful entrypoint casino_dispute_no_pick() =
    require_casino()
    ensure_player_turn_to_pick()
    require(state.height + state.reaction_time < Chain.block_height, "not_yet_allowed")
    Chain.spend(state.casino, Contract.balance)
    reset_state()

  // a friendly helper function
  entrypoint compute_hash(key: string, coin_side: string) : hash =
    ensure_coin_side(coin_side)
    String.sha256(String.concat(key, coin_side))
    
  // internal functions

  function ensure_coin_side(coin_side: string) =
    require(coin_side == "heads" || coin_side == "tails", "invalid_coin_side")

  function ensure_player_turn_to_pick() =
    require(state.hash != None, "no_hash")
    require(state.player_pick == None, "there_is_a_pick_already")
  
  function ensure_casino_turn_to_reveal() =
    require(state.player_pick != None, "there_is_no_pick")

  function require_player() =
    require(Call.caller == state.player, "not_player")
    
  function require_casino() =
    require(Call.caller == state.casino, "not_casino")

  function ensure_if_key_is_valid(key: string, coin_side: string) =
    let computed_hash = compute_hash(key, coin_side)
    let Some(stored_hash) = state.hash
    require(stored_hash == computed_hash, "invalid_key_and_answer")

  stateful function reset_state() =
    put(state{hash            = None,
              height          = 0,
              player_pick     = None,
              stake    = 0
              })
