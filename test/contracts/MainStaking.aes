include "List.aes"
contract interface StakingValidator =
  record validator_state = { main_staking_ct : address,
                             name : string,
                             description : string,
                             image_url : string,
                             delegates : map(address, int), shares : int }
  entrypoint init : (address) => unit
  payable stateful entrypoint stake : address => unit
  payable entrypoint profit : () => unit
  stateful entrypoint unstake : (address, int) => int
  entrypoint get_state : () => validator_state
  entrypoint balance : (address) => int
  entrypoint shares : (address) => int
  entrypoint all_shares : () => int
  stateful entrypoint set_name : (string) => unit
  stateful entrypoint set_description : (string) => unit
  stateful entrypoint set_avatar_url : (string) => unit

main contract MainStaking =
  datatype bucket = ONLINE | OFFLINE

  record pending_transfer =
    { validator : address,
      staker    : address,
      stake     : int}

  record validator =
    { ct              : StakingValidator,
      creation_height : int,
      stake           : int,
      pending_stake   : int,
      stake_limit     : int}

  record get_validator_response =
    { ct              : StakingValidator,
      address         : address,
      creation_height : int,
      stake           : int,
      pending_stake   : int,
      stake_limit     : int,
      is_online       : bool,
      state           : StakingValidator.validator_state}

  record get_state_response =
    { staking_validator_ct  : StakingValidator,
      validators            : list(get_validator_response),
      total_stake           : int,
      entropy               : hash,
      leader                : address,
      validator_min_stake   : int,
      validator_min_percent : int,
      stake_minimum         : int,
      online_delay          : int,
      stake_delay           : int
      }

  record state =
    { staking_validator_ct  : StakingValidator,
      online_validators     : map(address, validator),
      offline_validators    : map(address, validator),
      total_stake           : int,
      entropy               : hash,
      leader                : address,
      validator_min_stake   : int,
      validator_min_percent : int,
      stake_minimum         : int,
      online_delay          : int,
      stake_delay           : int,
      pending_stake         : map(int, list(pending_transfer))
      }

  entrypoint init(staking_validator_ct : StakingValidator,
                  entropy_str : string,
                  validator_min_stake : int,
                  validator_min_percent : int,
                  stake_minimum : int,
                  online_delay : int,
                  stake_delay : int
                  ) =
    { staking_validator_ct  = staking_validator_ct,
      online_validators     = {},
      offline_validators    = {},
      total_stake           = 0,
      entropy               = Crypto.sha256(entropy_str),
      leader                = Contract.address,
      validator_min_stake   = validator_min_stake,
      validator_min_percent = validator_min_percent,
      stake_minimum         = stake_minimum,
      online_delay          = online_delay,
      stake_delay           = stake_delay,
      pending_stake         = {}
      }

  entrypoint online_validators() =
    let vs = Map.to_list(state.online_validators)
    [ (v, s) | (v, {stake = s}) <- vs ]

  entrypoint offline_validators() =
    let vs = Map.to_list(state.offline_validators)
    [ (v, s) | (v, {stake = s}) <- vs ]

  payable stateful entrypoint new_validator() : StakingValidator =
    require(Call.value >= state.validator_min_stake, "A new validator stake the minimum amount")
    assert_uknown_validator(Call.caller)
    let validator_ct : StakingValidator = Chain.clone(ref = state.staking_validator_ct, Contract.address)
    validator_ct.stake(value = Call.value, Call.caller)
    let stake_limit = calculate_stake_limit(Call.value)
    put(state{offline_validators[Call.caller] = {
        ct = validator_ct,
        creation_height = Chain.block_height,
        stake = Call.value,
        pending_stake = 0,
        stake_limit = stake_limit}})
    validator_ct

  stateful entrypoint set_online() =
    require(validator_bucket(Call.caller) == OFFLINE, "Validator not offline")
    let validator = state.offline_validators[Call.caller]
    assert_allowed_to_set_online(validator)
    put(state{online_validators[Call.caller] = validator,
              offline_validators @ offv = Map.delete(Call.caller, offv),
              total_stake @ ts = ts + validator.stake})

  stateful entrypoint set_offline() =
    require(validator_bucket(Call.caller) == ONLINE, "Validator not online")
    let validator = state.online_validators[Call.caller]
    put(state{offline_validators[Call.caller] = validator,
              online_validators @ onv = Map.delete(Call.caller, onv),
              total_stake @ ts = ts - validator.stake})

  payable stateful entrypoint stake(to : address) =
    require(Call.value >= state.stake_minimum, "Must stake the minimum amount")
    switch(state.stake_delay)
      0 =>
        let validator : validator = get_validator(to)
        validator.ct.stake(value = Call.value, Call.caller)
        let new_validator = maybe_set_stake_limit(to, Call.caller, validator{ stake @ s = s + Call.value })
        switch(validator_bucket(to))
          ONLINE => put(state{online_validators[to] = new_validator, total_stake @ ts = ts + Call.value })
          OFFLINE => put(state{offline_validators[to] = new_validator})
      _ =>
        let validator : validator = get_validator(to)
        let new_validator = maybe_set_stake_limit(to, Call.caller, validator{ pending_stake @ ps = ps + Call.value })
        let height  = Chain.block_height + state.stake_delay
        let pending_transfer = { validator = to, staker = Call.caller, stake = Call.value}
        let ps = switch(Map.member(height, state.pending_stake))
            false => []
            true => state.pending_stake[height]
        put(state{pending_stake[height] = pending_transfer::ps})
        switch(validator_bucket(to))
          ONLINE => put(state{online_validators[to] = new_validator})
          OFFLINE => put(state{offline_validators[to] = new_validator})

         // total_stake @ ts = ts + Call.value,

  stateful entrypoint unstake(from : address, stakes : int) : int =
    switch(validator_bucket(from))
      ONLINE =>
        let validator = state.online_validators[from]
        let payout = validator.ct.unstake(Call.caller, stakes)
        assert_allowed_to_unstake(from, Call.caller, validator)
        let new_validator = set_stake_limit(from, validator)
        put(state{online_validators[from] = new_validator{ stake @ s = s - payout},
                  total_stake @ ts = ts - payout})
        payout
      OFFLINE =>
        let validator = state.offline_validators[from]
        let payout = validator.ct.unstake(Call.caller, stakes)
        assert_allowed_to_unstake(from, Call.caller, validator)
        let new_validator = set_stake_limit(from, validator)
        put(state{offline_validators[from] = new_validator{ stake @ s = s - payout }})
        payout

  payable stateful entrypoint reward(to : address) =
    assert_protocol_call()
    switch(validator_bucket(to))
      ONLINE =>
        let validator = state.online_validators[to]
        validator.ct.profit(value = Call.value)
        let new_validator = set_stake_limit(to, validator)
        put(state{online_validators[to] = new_validator{ stake @ s = s + Call.value },
                  total_stake @ ts = ts + Call.value})
      OFFLINE =>
        let validator = state.offline_validators[to]
        validator.ct.profit(value = Call.value)
        let new_validator = set_stake_limit(to, validator)
        put(state{offline_validators[to] = new_validator{ stake @ s = s + Call.value }})

  entrypoint get_validator_state(address : address) : get_validator_response =
    let validator = get_validator(address)
    let online =
        switch(validator_bucket(address))
            ONLINE => true
            OFFLINE => false
    get_validator_state_(address, validator, online)

  entrypoint get_state() : get_state_response =
    let validators = map_validators_state(state.online_validators, true) ++
                     map_validators_state(state.offline_validators, false)
    { staking_validator_ct  = state.staking_validator_ct,
      validators            = validators,
      total_stake           = state.total_stake,
      entropy               = state.entropy,
      leader                = state.leader,
      validator_min_stake   = state.validator_min_stake,
      validator_min_percent = state.validator_min_percent,
      stake_minimum         = state.stake_minimum,
      online_delay          = state.online_delay,
      stake_delay           = state.stake_delay
      }

  entrypoint set_validator_name(name : string) =
    let validator = get_validator(Call.caller)
    validator.ct.set_name(name)

  entrypoint set_validator_description(description : string) =
    let validator = get_validator(Call.caller)
    validator.ct.set_description(description)

  entrypoint set_validator_avatar_url(avatar_url : string) =
    let validator = get_validator(Call.caller)
    validator.ct.set_avatar_url(avatar_url)

  entrypoint leader() =
    state.leader

  stateful entrypoint elect() =
    assert_protocol_call()
    let height = Chain.block_height
    let new_leader = elect_at_height(height)
    switch(Map.member(height, state.pending_stake))
      false => ()
      true =>
        let payouts = state.pending_stake[height]
        List.foreach(payouts, distribute_payout)
        let new_ps = Map.delete(height, state.pending_stake)
        put(state{pending_stake = new_ps})
    put(state{ leader = new_leader })

  stateful function distribute_payout(payout) =
    let validator : validator = get_validator(payout.validator)
    validator.ct.stake(value = payout.stake, payout.staker)
    let new_validator = validator{ stake @ s = s + payout.stake, pending_stake @ ps = ps - payout.stake}
    switch(validator_bucket(payout.validator))
      ONLINE => put(state{online_validators[payout.validator] = new_validator, total_stake @ ts = ts + payout.stake})
      OFFLINE =>
        put(state{offline_validators[payout.validator] = new_validator})

  entrypoint elect_next() =
    elect_at_height(Chain.block_height + 1)

  entrypoint elect_at_height(height : int) =
    let sorted = List.sort(validator_cmp, Map.to_list(state.online_validators))
    let shot = Bytes.to_int(state.entropy) * height mod state.total_stake
    switch(find_validator(sorted, shot))
      None => abort("NO CANDIDATE") // should not be possible
      Some(new_leader) => new_leader

  entrypoint staking_power(who : address) =
    let validator = get_validator(who)
    validator.stake

  entrypoint is_validator_online(who : address) =
    switch(validator_bucket(who))
      ONLINE => true
      OFFLINE => false

  entrypoint get_validator_contract(who : address) =
    let validator = get_validator(who)
    validator.ct

  function get_validator(who : address) : validator =
    switch(validator_bucket(who))
      ONLINE => state.online_validators[who]
      OFFLINE => state.offline_validators[who]

  stateful function set_validator(who : address, v : validator) : unit =
    switch(validator_bucket(who))
      ONLINE => put(state{online_validators[who] = v})
      OFFLINE => put(state{offline_validators[who] = v})

  function assert_uknown_validator(who) : bool =
    switch(Map.member(who, state.online_validators))
      true =>
        abort("Validator exists")
      false =>
        switch(Map.member(who, state.offline_validators))
          true =>
            abort("Validator exists")
          false =>
            true

  function find_validator(validators, shot) =
    switch(validators)
      []   => None
      (validator_addr, validator : validator)::t =>
        if(validator.stake > shot) Some(validator_addr)
        else find_validator(t, shot - validator.stake)

  function validator_cmp((x_addr : address, x : validator), (y_addr : address, y : validator)) =
    if (x.stake == y.stake) x_addr < y_addr else x.stake < y.stake

  function validator_bucket(who) : bucket =
    switch(Map.member(who, state.online_validators))
      true =>
        ONLINE
      false =>
        switch(Map.member(who, state.offline_validators))
          true =>
            OFFLINE
          false =>
            abort("Validator must exists")

  function assert_protocol_call() =
      require(Call.caller == Contract.creator, "Must be called by the protocol")

  function get_validator_state_(address : address, validator : validator, is_online : bool) : get_validator_response =
    {ct = validator.ct,
     address = address,
     creation_height = validator.creation_height,
     stake = validator.stake,
     pending_stake = validator.pending_stake,
     stake_limit = validator.stake_limit,
     is_online = is_online,
     state = validator.ct.get_state()}

  function map_validators_state(map, is_online) =
    [get_validator_state_(addr, validator, is_online) | (addr, validator) <- Map.to_list(map)]

  function assert_allowed_to_unstake(from : address, who : address, v : validator) =
    if(from == who)
      let balance_left = v.ct.balance(from)
      assert_min_stake(balance_left)
      assert_min_percent_stake(who, balance_left)
    else
      true

  function assert_min_stake(balance : int) =
      if(balance < state.validator_min_stake)
        abort("Validator can not withdraw below the treshold")
      else false

  function assert_min_percent_stake(v: address, balance : int) =
      let validator = get_validator_state(v)
      let min_percent = state.validator_min_percent
      if((100 * balance) < (min_percent * validator.stake))
        abort("Validator can not withdraw below the 30% treshold")
      else false

  stateful function maybe_set_stake_limit(to : address, who : address, v : validator) : validator =
    if(to == who) set_stake_limit(to, v)
    else assert_stake_limit(v)

  function set_stake_limit(v_address : address, v : validator) : validator =
    let balance = v.ct.balance(v_address)
    v{ stake_limit = calculate_stake_limit(balance) }

  function calculate_stake_limit(stake : int) : int =
    stake * 100 / state.validator_min_percent

  function assert_stake_limit(v : validator) : validator =
    if(v.stake_limit < v.stake + v.pending_stake) abort("Total stake limit exceeded")
    else v

  function assert_allowed_to_set_online(v : validator) =
    if(v.creation_height + state.online_delay =< Chain.block_height) true
    else abort("Minimum height not reached")
